<!--
	autogenerated by scripts/doc/generate.lua
	from scripts/doc/src/index.template.md
-->
# `lsp = require("lsp-lib")`

the "Spring Boot" of the API. It gives all the functionality needed to build
a typical LSP server.

Example:

```lua
local null = require("cjson").null
local lsp = require("lsp-lib")
local ErrorCodes = require("lsp-lib.enum.ErrorCodes")

---@type lsp.ClientCapabilities
local server_config

-- this allows adding fields to the type
---@class lsp-lib.Request
lsp.request = lsp.request

-- "initialize" should auto-complete well enough under LuaLS
lsp.response["initialize"] = function(params)
  -- annotation is needed here due to a shortcoming of LuaLS
  ---@type lsp.Response.initialize.result
  return { capabilities = {} }
end

lsp.response["initialized"] = function()
  -- utility notify functions are provided
  lsp.notify.log.info(os.date())

  -- make a blocking LSP request
  local err
  server_config, err = lsp.request.config()
  if err then
    -- errors in notification handlers are logged to the client
    error("Error in `initialized` handler: " .. err.message)
  end
end

lsp.response["shutdown"] = function()
  -- notify the client of something
  lsp.notify["$/cancelRequest"] { id = 0 }
  -- there is also a library function for this
  lsp.notify.cancel_request(0)

  local something_bad_happened = math.random() < 0.5
  if something_bad_happened then
    -- errors in response handlers send a response error and logs them to the
    -- client
    error({
      code = ErrorCodes.InternalError,
      message = "Something bad happened!",
    })
  end

  return null
end

-- define your own request function
function lsp.request.custom_request(foo, bar)
  return lsp.request("$/customRequest", { foo = foo, bar = bar })
end

-- turn on debugging
-- currently logs anything received by or sent from this server
lsp.debug(true)

-- starts a loop that listens to stdio
lsp.listen()
```


## `lsp.notify`

```
lsp-lib.Notify
```

sends notifications to the client. Unlike requests, notifications never
block the current thread and return nothing.

When indexed with an LSP-specified method, it returns a function that takes
a `params` argument. This form is entirely type-checked by LuaLS.

When `notify` is called, it takes an LSP-specified `method` argument and a
`params` argument. This form is loosely type-checked by LuaLS and is
typically used by other notification functions.

This table also contains utility functions for all LSP-specified methods.

Example:

```lua
-- three ways to send a `window/logMessage` notification:

local MessageType = require('lsp-lib.enum.MessageType')

-- calling `notify`, loosely typed
notify('window/logMessage', {
  type = MessageType.Info,
  message = "server version: X.Y.Z",
})

-- indexing `notify`, strictly typed with Intellisense
notify['window/logMessage'] {
  type = MessageType.Info,
  message = "server version: X.Y.Z",
}

-- calling `notify.log.*`, strictly typed with Intellisense
notify.log.info("server version: X.Y.Z")
```


## `lsp.debug`

```
function
```

sets debug mode to its boolean `setting` parameter. Right now, its only
effect is logging all messages that are read from and written to the server.


## `lsp.async`

```
fun(f: function, ...any):(thread: thread, ok: boolean, ...any)
```

a utility function for calling a function `f` asynchronously with arguments
`...`. A `thread` object representing the call is returned.


## `lsp.request`

```
lsp-lib.Request
```

sends LSP requests to the client. Requests block the current thread and
return the response's result xor error object.
[`lsp-lib.async`](lua://lsp-lib.Async) is provided for sending requests
asynchronously.

When in a response function, `assert`ing the request will echo the client's
response back as-is, which is likely unintended behavior. Instead, take the
message and wrap it in a meaningful `InternalError`.

```lua
local ErrorCodes = require("lsp-lib.enum.ErrorCodes")
local lsp = require("lsp-lib")

lsp.response["initialized"] = function(params)
  local config, err = lsp.request.config()
  if err then
    error({
      code = ErrorCodes.InternalError,
      message = "Error in `initialized` handler: " .. err.message,
    })
  end

  -- process config safely
end
```

When indexed with an LSP-specified method, it returns a function that takes
a `params` argument. This form is entirely type-checked by LuaLS.

When `request` is called, it takes an LSP-specified `method` argument and a
`params` argument. This form is very loosely type-checked by LuaLS and is
typically used by other request functions.

This table also contains utility functions for all LSP-specified methods.

Example:

```lua
-- three ways to send a `workspace/configuration` request:

-- calling `request`, loosely typed
local config, err = lsp.request('workspace/configuration', {
  items = { { section = "server.config" } },
})

-- indexing `request`, strictly typed with Intellisense
local config, err = lsp.request['workspace/configuration'] {
  items = { { section = "server.config" } },
}

-- calling `request.config`, strictly typed with Intellisense
local config, err = lsp.request.config( { section = "server.config" } )
```


## `lsp.listen`

```
lsp-lib.Listen
```

manages messages read from input, routes them through its response handlers,
and sends what they return to output

This module also resumes requesting threads when receiving responses and
logs errors to the client when a route errors.

Calling this module starts a blocking I/O loop. It's dependent on
[`lsp-lib.io`](lua://lsp-lib.IO) to read and write these messages.

If the `exit` parameter is anything but `false`, `listen()` will call
`os.exit` after receiving the
[`exit` notification](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#exit).
`listen(false)` will simply assert that the server was left in a finished
state before returning. This is used for writing tests.


## `lsp.response`

```
lsp-lib.Response
```

a table that is meant to be populated with route implementations by the user.
This is the default table `lsp.listen` uses to query routes.

Below is an example of a route implementation for the `initialize` request.

```lua
local TextDocumentSyncKind = require("lsp-lib.enum.TextDocumentSyncKind")
local lsp = require("lsp-lib")

lsp.response['initialize'] = function(params)

  ---@type lsp.ServerCapabilities
  local capabilities = {
    textDocumentSync = {
      openClose = true,
      change = TextDocumentSyncKind.Incremental,
    },

    diagnosticProvider = {
      interFileDependencies = true,
      workspaceDiagnostics = true,
      documentSelector = {
        { language = "plain", scheme = "file" },
      },
    },

    -- other capabilities...
  }

  ---@type lsp.Response.initialize.result
  local response = {
    capabilities = capabilities,
    serverInfo = {
      name = "plain text language server",
      version = "0.0.1",
    },
  }

  return response
end
```

And here is another example for the `textDocument/didOpen` notification.

```lua
local lsp = require("lsp-lib")

-- a module that holds a reference to all opened documents
local documents = require("server.documents")

lsp.response["textDocument/didOpen"] = function(params)
  local document = params.textDocument

  documents[document.uri] = document
end
```

If a route throws an error, it could get handled in several ways based on the
kind of error object that was passed:

- When the error object is a table with a `message` and `code` field, it's
  treated as a response error directly, and the `message` field is treated as
  an error message.
- Otherwise, a response error with an `InternalError` code is generated with
  the given value as its `message` field.

If the error was caught within a request route, a response error is sent. In
all cases, the error message is logged.

If a route is queried but unimplemented, an error is logged, and a response
error with a `MethodNotFound` code is sent if required.

If a request implementation does not return a response value, an error is
logged, and a response error with an `InternalError` code is sent. If a
notification implementation returns a value, an error is logged.

All supported request and notification implementations are outlined in the
[LSP 3.17 specification](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/),
and custom requests and notifications can be implemented.

